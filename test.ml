(* We split up the OUnit testing for our 3 modules, game_mechanics, command 
   and save into 3 separate testing files: test_mechanics, test_command and 
   test_save respectively, so that each module could be tested without 
   the others being fully developed. 

   For game_mechanics testing, we first simulated games by creating a function 
   that would make moves from a given list, and then used that state at the end
   of all the moves made resulted in a win or draw. This was to check that 
   pieces were being placed correctly and that a win or draw could be detected.
   The game moves were first generated by hand to make sure that wins made near
   the edge of a board (like a diagonal win that has a piece in the edgemost 
   column) would still be detected correctly. After generating a couple game 
   moves by hand for both wins and losses of each type of win: row, column, 
   and diagonals, we used an online connect 4 game simulator
   https://www.mathsisfun.com/games/connect4.html where we had two computers
   play against each other and then used the moves they made to generate random
   win tests.
   After adding special game piece functionality, we created functions to make 
   special piece moves to test that placing those pieces worked correctly, by 
   checking the output of the gameboard and/or if there was a win. We also did 
   glass box testing by testing our hand (the special pieces you have) and 
   number of special pieces a player has after making a move with a special 
   piece are working correctly. 

   For command testing, we did black box testing, first testing that each 
   command given correctly works and then came up with random incorrect 
   command tests, to ensure that our command module works correctly for 
   different kinds of inputs.

   For save testing, we first did glass box testing as we tested that making 
   jsons works, a function that is used by save and load, by checking that 
   game strings we created could be converted to jsons. We then did black box 
   testing for save and load. For load, we tested that we could load jsons of 
   both customized and uncustomized games, and that we can't load files that 
   don't exist. For save, we tested that we tested that the strings we had 
   previously created for the json testing could be saved to a file. 

   Since this is a game, we tested our display and ai modules by 
   running our main module to use the game console in the terminal.
   We did extensive testing of our game interface by playing games ourselves 
   and having our family members play games as well. 
   This also allowed us to indirectly test that the game_mechanics, command
   and save modules were working correctly, by inputting incorrect commands,
   making sure that the game board is printed correctly for special moves and 
   that we can save and load games.

   We believe our testing strategy of both using OUnit tests for formal testing 
   with both strategic and randomized tests, along with our manual testing with  
   the game console in the terminal demonstrates that our system is functioning 
   correctly, as we tested how our modules and console react to both correct
   and incorrect inputs. Also by having our family members play our game, we 
   were able to have our system tested by people outside of our team, people 
   who are unfamiliar with our system and could input more incorrect commands 
   that could break our system, but our system remained intact, worked 
   correctly and our game was playable. In addition this made sure that our 
   game interface was usable by people unfamiliar with the system.

*)
